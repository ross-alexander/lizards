head	1.4;
access;
symbols;
locks
	ralexand:1.4; strict;
comment	@// @;


1.4
date	2016.12.27.08.39.35;	author ralexand;	state Exp;
branches;
next	1.3;

1.3
date	2012.11.15.18.39.58;	author ralexand;	state Exp;
branches;
next	1.2;

1.2
date	2011.08.31.12.36.30;	author ralexand;	state Exp;
branches;
next	1.1;

1.1
date	2011.08.23.15.42.00;	author ralexand;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Summary: Move hull into fplace_t and hull creation into place.
@
text
@#include <string>
#include <map>
#include <vector>
#include <typeinfo>

#include <assert.h>
#include <sys/syslog.h>

#include <cairomm/context.h>
#include <librsvg/rsvg.h>

#include <json-c/json.h>

#include "lizards.h"

/* ----------------------------------------------------------------------
--
-- structures
--
---------------------------------------------------------------------- */

struct svgmap_t {
  int output;
  const char *type;
  const char *svgfile;
  RsvgHandle *handle;
};

class output_private_t {
public:
  grid_t *grid;
  void path_extents(Cairo::RefPtr<Cairo::Context> cr);
  void path_paint_hex(Cairo::RefPtr<Cairo::Context> cr, overlay_hex_t*);
  void path_paint(Cairo::RefPtr<Cairo::Context> cr);
  fplace_t place(point_t, double, double);
  void overlay(int);
  int player;
  double radius;
  int width;
  int height;
  fbox_t edge;

  std::vector<overlay_hex_t*>hexes;
  
  output_private_t(grid_t*, int);
  fbox_t paint(Cairo::RefPtr<Cairo::Context> cr);
  static svgmap_t svgmap[OUTPUT_LAST];
  std::map<int, svgmap_t*> id2sym;
  std::map<std::string, svgmap_t*> type2sym;
  hex_t *hit(double, double, double, double);
};

#define min(a, b) (a < b ? a : b)

svgmap_t output_private_t::svgmap[OUTPUT_LAST] = {
  {OUTPUT_BLANK,     	BLANK,		0},
  {OUTPUT_WATER,     	WATER,		0},
  {OUTPUT_PLAINS, 	PLAINS,		"svg/plains.svg"},
  {OUTPUT_WHIRLPOOL,   	WHIRLPOOL,	"svg/whirlpool.svg"},
  {OUTPUT_FERTILE,	PLAINS,		"svg/fertile.svg"},
  {OUTPUT_SWAMP,       	SWAMP,		"svg/swamp.svg"},
  {OUTPUT_SCRUB,       	SCRUB,		"svg/scrub.svg"},
  {OUTPUT_PEAK,		PEAK,		"svg/peak.svg"},
  {OUTPUT_VOLCANO,     	VOLCANO,	"svg/volcano.svg"},
  {OUTPUT_HALF_DEN,   	HALF_DEN,	"svg/half_den.svg"},
  {OUTPUT_EMPTY_DEN,	EMPTY_DEN,	"svg/den.svg"},
  {OUTPUT_RED_DEN,	RED_DEN,	"svg/den-red.svg"},
  {OUTPUT_GREEN_DEN,	GREEN_DEN,	"svg/den-green.svg"},
  {OUTPUT_GREY_DEN,	GREY_DEN,	"svg/den-grey.svg"},
  {OUTPUT_BLACK_DEN,	BLACK_DEN,	"svg/den-black.svg"},
  {OUTPUT_YELLOW_DEN,	YELLOW_DEN,	"svg/den-yellow.svg"},
  {OUTPUT_HOME_DEN,	0,		"svg/den-home.svg"},
  {OUTPUT_TEMPLE,	TEMPLE,		"svg/temple.svg"},
  {OUTPUT_CURSED,   	CURSED,		"svg/cursed.svg"},
  {OUTPUT_RUIN,		RUIN,		"svg/ruin.svg"},
  {OUTPUT_BAND,       	BAND,		"svg/band.svg"},
  {OUTPUT_BRIDGE,      	BRIDGE,		"svg/bridge.svg"},
  {OUTPUT_RAFT,       	RAFT,		"svg/raft.svg"},
  {OUTPUT_LIZARD,	0,		"svg/lizard.svg"},
};


/* ----------------------------------------------------------------------
--
-- place
--
-- Places a hex onto the cartesian plane, applying the vertical shift
-- and scaling the final output
--

      -0.5r,-sqrt(3)/2*r    
            +------+------+           
           / \     |     / \
          /   \    |    /   \   
         /    sqrt(3)/2*r    \  
        /       \  |  /       \ 
       /         \ | /         \
      /           \|/           \
      +---- r -----+-------------+
                 0,0            +r,0

-- System uses raster (top = 0) coordinates
--
---------------------------------------------------------------------- */

fplace_t output_private_t::place(point_t p, double radius, double border)
{
  double yshift = (double)(abs(p.x) % 2) / 2.0;
  double cx = 1.50 * p.x * radius;
  double cy = sqrt(3) * ((double)p.y - yshift) * radius;

  fplace_t place;
  place.center = fpoint_t(cx, cy);
  place.bounds.left = place.center.x - radius - border;
  place.bounds.right = place.center.x + radius + border;
  place.bounds.top = place.center.y - sqrt(3)/2 * radius - border;
  place.bounds.bottom = place.center.y + sqrt(3)/2 * radius + border;

  for (int j = 0; j < 6; j++)
    {
      double x = cos(j * 60 * M_PI / 180);
      double y = sin(j * 60 * M_PI / 180);
      place.hull.push_back(fpoint_t(cx + x * radius, cy + y * radius));
    }
  return place;
}

/* ----------------------------------------------------------------------
--
-- path_extents
--
---------------------------------------------------------------------- */

void output_private_t::path_extents(Cairo::RefPtr<Cairo::Context> cr)
{
  cr->begin_new_path();
  for (auto hex : hexes)
    {
      if (hex == 0)
	continue;

      cr->begin_new_sub_path();
      cr->move_to(hex->place.hull[0].x, hex->place.hull[0].y);
      for (int i = 1; i < 6; i++)
	cr->line_to(hex->place.hull[i].x, hex->place.hull[i].y);
      cr->close_path();
    }
}

/* ----------------------------------------------------------------------
--
-- path_paint
--
---------------------------------------------------------------------- */

void output_private_t::path_paint_hex(Cairo::RefPtr<Cairo::Context> cr, overlay_hex_t* ovh)
{
  hex_t *hex = ovh->hex;
  if (hex == 0)
    return;
  
  int symbol;
  char *trailer = 0;
  char *header = 0;
  
/* --------------------
   Let hex decide what is visible
   -------------------- */

  view_t v = hex->view(player);
  symbol = v.symbol;
  header = (char*)(v.owner.c_str());
  trailer = (char*)(v.id.c_str());

  misc_t::log(LOG_DEBUG, "header=%s trailer=%s symbol=%d", header, trailer, symbol);
  
/* --------------------
   Create path from hull
   -------------------- */

  cr->begin_new_path();
  cr->move_to(ovh->place.hull[0].x, ovh->place.hull[0].y);
  for (int i = 1; i < 6; i++)
    cr->line_to(ovh->place.hull[i].x, ovh->place.hull[i].y);
  cr->close_path();

  /* --------------------
     Set fill colour
     -------------------- */
  
  switch(symbol)
    {
    case OUTPUT_WATER:
    case OUTPUT_WHIRLPOOL:
    case OUTPUT_BRIDGE:
      cr->set_source_rgb(0.80, 0.94, 0.99);
      break;
    case OUTPUT_BLANK:
      cr->set_source_rgb(0.8, 0.8, 0.8);
      break;
    default:
      cr->set_source_rgb(0.80, 0.99, 0.80);
      break;
    }
  cr->fill_preserve();

  /* --------------------
     Paint hex border
     -------------------- */
  
  cr->set_line_width(0.2);
  cr->set_source_rgb(0.0, 0.0, 0.0);
  if (ovh->hex->active)
    {
      fprintf(stderr, "%s active\n", ovh->hex->getid().c_str());
      cr->set_line_width(2.0);
      cr->set_source_rgb(1.0, 1.0, 0.0);
    }
  cr->stroke();
  
  /* --------------------
     Place icon (base size is 200x200) scaled by 0.20 to 40x40 so image is places at cx-20, cy-15 to cx+20, cy+25
     -------------------- */
  
  double cx = ovh->place.center.x;
  double cy = ovh->place.center.y;
  
  if (id2sym[symbol] && id2sym[symbol]->handle)
    {
      cr->save();
      cairo_t *c = (cairo_t*)(cr->cobj());
      cr->translate(cx - 20.0, cy - 15.0);
      cr->scale(0.20, 0.20);
      rsvg_handle_render_cairo(id2sym[symbol]->handle, c);
      cr->restore();
    }

  cr->set_source_rgb(0.0, 0.0, 0.0);

  Cairo::TextExtents e;
  if (trailer)
    {
      cr->get_text_extents(trailer, e);
      cr->move_to(cx -e.width/2, cy + sqrt(3)/2*radius - 2);
      cr->show_text(trailer);
    }
  
  cr->save();
  cr->set_source_rgb(1.0, 0.0, 0.0);
  if (header)
    {
      cr->get_text_extents(header, e);
      cr->move_to(cx - e.width/2, cy - sqrt(3)/2*radius + e.height + 2);
      cr->show_text(header);
    }
  cr->restore();
  
  /* --------------------
     Add band - needs code to deal with visibility
     -------------------- */
  
  if (v.band)
    {
      char band[10];
      snprintf(band, 10, "%d", v.band);
      cr->get_text_extents(band, e);
      cr->move_to(cx - e.width, cy - 5);
      cr->show_text(band);
      cr->save();
      cr->translate(cx, cy - 25);
      cr->scale(0.15, 0.15);
      rsvg_handle_render_cairo(id2sym[OUTPUT_LIZARD]->handle, (cairo_t*)(cr->cobj()));
      cr->restore();
    }
}

  
/* ----------------------------------------------------------------------
--
-- path_paint
--
---------------------------------------------------------------------- */

void output_private_t::path_paint(Cairo::RefPtr<Cairo::Context> cr)
{
  for (auto hex : hexes)
    {
      path_paint_hex(cr, hex);
    }
  for (auto hex : hexes)
    {
      cr->begin_new_path();
      cr->move_to(hex->place.hull[0].x, hex->place.hull[0].y);
      for (int i = 1; i < 6; i++)
	cr->line_to(hex->place.hull[i].x, hex->place.hull[i].y);
      cr->close_path();

      if (hex->hex->active)
	{
	  fprintf(stderr, "%s active\n", hex->hex->getid().c_str());
	  cr->set_source_rgb(1.0, 1.0, 0.0);
	  cr->set_line_width(2.0);
	  cr->stroke();
	}
      if ((player > 0) && (player == hex->hex->owner))
	{
	  cr->set_line_width(1.0);
	  cr->set_source_rgb(1.0, 0.0, 0.0);
	  cr->stroke();
	}
    }
}

/* ----------------------------------------------------------------------
--
-- paint
--
---------------------------------------------------------------------- */

fbox_t output_private_t::paint(Cairo::RefPtr<Cairo::Context> cr)
{
  fbox_t fb;

  cr->select_font_face("Bitstream Vera Sans", Cairo::FONT_SLANT_NORMAL, Cairo::FONT_WEIGHT_NORMAL);
  cr->set_font_size(10);

  Cairo::FontOptions font_options;

  font_options.set_hint_style(Cairo::HINT_STYLE_NONE);
  font_options.set_hint_metrics(Cairo::HINT_METRICS_OFF);
  font_options.set_antialias(Cairo::ANTIALIAS_GRAY);
  cr->set_font_options(font_options);

  cr->save();
  path_extents(cr);
  cr->set_line_width(0.4);
  cr->get_stroke_extents(fb.left, fb.top, fb.right, fb.bottom);
  cr->restore();

  misc_t::log(LOG_INFO, "stroke extents left = %f top = %f", fb.left, fb.top);

  cr->save();
  cr->set_source_rgb(1, 1, 1);
  //  cr->translate(-fb.left + border, -fb.top + border);
  cr->translate(-fb.left, -fb.top);
  path_paint(cr);
  cr->restore();
  return fb;
}

/* ----------------------------------------------------------------------
--
-- overlay
--
---------------------------------------------------------------------- */

void output_private_t::overlay(int p)
{
  overlay_grid_t *ov = new overlay_grid_t(grid);
  ov->mark(p);
  hexes = ov->extract(p);

  /* --------------------
     Make sure we have atleast one hex
     -------------------- */

  assert(hexes.size() > 0);
  
  /* --------------------
     Center as much as possible
     -------------------- */
  
  if (p > 0)
    {
      int min_weight = grid->width * grid->height * grid->width * grid->height;
      overlay_hex_t* hex_min_weight;

      for (auto a : hexes)
	{
	  int x = a->xy.x;
	  int y = a->xy.y;
	  
	  int total = 0;
	  for (auto b : hexes)
	    {
	      int xd = abs(b->xy.x - x);
	      int yd = abs(b->xy.y - y);
	      total += min(xd, grid->width - xd);
	      total += min(yd, grid->height - yd);
	    }
	  if (total < min_weight)
	    {
	      min_weight = total;
	      hex_min_weight = a;
	    }
	}
      point_t center = hex_min_weight->xy;
      center.x -= center.x%2;

      point_t middle(grid->width / 2, grid->height / 2);
      point_t diff = middle - center;
      assert(diff.x%2 == 0);

      misc_t::log(LOG_DEBUG, "Hex %s (%d,%d) has minimum weight %d", hex_min_weight->hex->getid().c_str(), hex_min_weight->xy.x, hex_min_weight->xy.y, min_weight);

      for (auto hex : hexes)
	{
	  point_t pt = hex->xy + diff;
	  if (pt.x < 0) pt.x += grid->width;
	  if (pt.x >= grid->width) pt.x -= grid->width;

	  if (pt.y < 0) pt.y += grid->height;
	  if (pt.y >= grid->width) pt.y -= grid->height;
	  hex->xy = pt;
	}
    }

/* ----------------------------------------------------------------------

      -0.5r,-sqrt(3)/2*r    
            +------+------+           
           / \     |     / \
          /   \    |    /   \   
         /     \ sqrt(3)r    \  
        /       \  |  /       \ 
       /         \ | /         \
      /           \|/           \
      +---- r -----+-------------+
                 0,0            +r,0

System uses raster (top = 0) coordinates

--------------------------------------------------------------------- */

  for (auto hex : hexes)
    {
      point_t o = hex->xy;
      fplace_t b = place(o, radius, 0);
      //      hex->center = b.center;
      hex->place = b;
      
      edge.setunion(b.bounds);
      //      printf("edge.left = %f, edge.right = %f, edge.top = %f, edge.bottom = %f\n", edge.left, edge.right, edge.top, edge.bottom);
    }
  width = (edge.right - edge.left);
  height = (edge.bottom - edge.top);
}


/* ----------------------------------------------------------------------
--
-- output_private_t(grid_t *g, int p)
--
---------------------------------------------------------------------- */

output_private_t::output_private_t(grid_t *g, int p)
{

  /* --------------------
     Load SVG icons
     -------------------- */
  
  int nmap = sizeof(svgmap)/sizeof(svgmap_t);
  for (int i = 0; i < nmap; i++)
    {
      if (svgmap[i].svgfile)
	svgmap[i].handle = rsvg_handle_new_from_file(svgmap[i].svgfile, 0);
      else
	svgmap[i].handle = 0;

      id2sym[svgmap[i].output] = &svgmap[i];
      if (svgmap[i].type)
	type2sym[svgmap[i].type] = &svgmap[i];
    }

  /* --------------------
     Base scale is 40.0 units hex radius
     -------------------- */
  
  radius = 40.0;
  grid = g;
  player = p;
  
  /* --------------------
     Call overlay to get hexes for player p
     -------------------- */
  
  overlay(player);
}


/* ----------------------------------------------------------------------
--
-- svg
--
---------------------------------------------------------------------- */

singles_t* output_t::svg(char *file, int p)
{
  /* --------------------
     Get hexes and bounding box (unscaled)
     -------------------- */

  priv = new output_private_t(grid, p);

  /* --------------------
     borders are not scaled
     -------------------- */
  
  int width = priv->width * scalef + 2 * border;
  int height = priv->height * scalef + 2 * border;

  Cairo::RefPtr<Cairo::SvgSurface> surface = Cairo::SvgSurface::create(file, width, height);
  Cairo::RefPtr<Cairo::Context> cr = Cairo::Context::create(surface);

  /* --------------------
     translate for to fit in 0,0+width,height box
     -------------------- */

  misc_t::log(LOG_DEBUG, "output_t::svg(%f,%f+%f,%f)", priv->edge.left,priv->edge.top,priv->edge.right,priv->edge.bottom);

  cr->translate(border, border);
  cr->scale(scalef, scalef);
  cr->translate(-priv->edge.left, -priv->edge.top);
  
  singles_t* singles = new singles_t;
  overlay_hex_t *active = nullptr;

  for (auto hex : priv->hexes)
    {
      assert(hex);
      //      single_t s;
      //      s.center = oh->place.center;
      //      s.bounds = oh->place.bounds;
      
      //      if (i == 0)
      //	singles->bounds = s.bounds;
      //      else
      //       	singles->bounds.setunion(s.bounds);
      
      //      int w = s.bounds.right - s.bounds.left + 2 * priv->border;
      //      int h = s.bounds.bottom - s.bounds.top + 2 * priv->border;
      
      //      assert(w > 0);
      //      assert(h > 0);

      //      s.id = strdup(oh->hex->getid().c_str());
      //      fprintf(stderr, "output_t::svg(%s)\n", s.id);

      //      for (int k = 0; k < 6; k++)
      //	s.path.push_back(oh->hull[k] + tr);

      //      singles->singles.push_back(s);

      //      cr->translate(-s.bounds.left + priv->border, -s.bounds.top + priv->border);

      if (hex->hex->active)
	active = hex;
      else
	priv->path_paint_hex(cr, hex);
    }
  /* --------------------
     Output active last
     -------------------- */
  
  if (active) priv->path_paint_hex(cr, active);
  
  //  singles->bounds.right += 2 * priv->border;
  //  singles->bounds.bottom += 2 * priv->border;
  return singles;
}

/* ----------------------------------------------------------------------
--
-- single
--
---------------------------------------------------------------------- */

singles_t* output_t::single(char *path, int p)
{
  priv = new output_private_t(grid, p);
  singles_t* singles = new singles_t;

  // char file[1024];
  /*  
  for (int i = 0; priv->ohl[i]; i++)
    {
      overlay_hex_t *oh = priv->ohl[i];
      assert(oh);
      single_t s;
      s.center = oh->place.center;
      s.bounds = oh->place.bounds;

      if (i == 0)
	singles->bounds = s.bounds;
      else
       	singles->bounds.setunion(s.bounds);
      
      int w = s.bounds.right - s.bounds.left + 2 * priv->border;
      int h = s.bounds.bottom - s.bounds.top + 2 * priv->border;

      assert(w > 0);
      assert(h > 0);

      snprintf(file, 1024, path, i);
      s.file = strdup(file);
      s.id = strdup(oh->hex->getid().c_str());
      singles->singles.push_back(s);

      Cairo::RefPtr<Cairo::SvgSurface> surface = Cairo::SvgSurface::create(file, w, h);
      Cairo::RefPtr<Cairo::Context> cr = Cairo::Context::create(surface);
      cr->translate(-s.bounds.left + priv->border, -s.bounds.top + priv->border);
      priv->path_paint_hex(cr, oh);
    }
  singles->bounds.right += 2 * priv->border;
  singles->bounds.bottom += 2 * priv->border;
  */
  return singles;
}

/* ----------------------------------------------------------------------
--
-- output_t::json
--
---------------------------------------------------------------------- */

void* output_t::json(char *file, int p)
{
  return 0;
}

/* ----------------------------------------------------------------------
--
-- output_t::hit
--
---------------------------------------------------------------------- */
hex_t* output_t::hit(double x, double y, double w, double h)
{
  priv = new output_private_t(grid, 0);
  return priv->hit(x, y, w, h);
}


hex_t* output_private_t::hit(double x, double y, double w, double h)
{
  hex_t *hit = 0;

  double nx = x/w * width;
  double ny = y/h* height;

  misc_t::log(LOG_DEBUG, "nx,ny = %f,%f : width,height = %d,%d", nx, ny, width, height);

  Cairo::RefPtr<Cairo::SvgSurface> surface = Cairo::SvgSurface::create("/dev/null", width, height);
  Cairo::RefPtr<Cairo::Context> cr = Cairo::Context::create(surface);

  fbox_t fb;
  cr->save();
  path_extents(cr);
  cr->set_line_width(0.4);
  cr->get_stroke_extents(fb.left, fb.top, fb.right, fb.bottom);
  cr->restore();

  //  nx += fb.left - border;
  //  ny += fb.top - border;

  cr->save();
  //  cr->translate(-fb.left + border, -fb.top + border);
  for (auto ohex : hexes)
    {
      if (ohex == 0)
	continue;
      ohex->hex->active = 0;

      cr->begin_new_path();
      cr->move_to(ohex->place.hull[0].x, ohex->place.hull[0].y);
      for (int i = 1; i < 6; i++)
	cr->line_to(ohex->place.hull[i].x, ohex->place.hull[i].y);
      cr->close_path();
      if (cr->in_fill(nx, ny))
	{
	  hit = ohex->hex;
	  ohex->hex->active = 1;
	  misc_t::log(LOG_NOTICE, "Hit for hex %s", hit->getid());
	}
    }
  cr->restore();
  return hit;
}

/* ----------------------------------------------------------------------
--
-- singles_t
--
---------------------------------------------------------------------- */
unsigned int singles_t::size()
{
  return (*this).singles.size();
}

/* ----------------------------------------------------------------------
--
-- output_t(grid_t*)
--
---------------------------------------------------------------------- */

output_t::output_t(grid_t *gd)
{
  grid = gd;
  game = nullptr;
  scalef = 1.0;
  border = 5.0;
}

/* ----------------------------------------------------------------------
--
-- output_t(game_t*)
--
---------------------------------------------------------------------- */

output_t::output_t(game_t *ga)
{
  game = ga;
  grid = ga->grid;
  scalef = 1.0;
  border = 5.0;
}
@


1.3
log
@Move cairo stuff into private class.
@
text
@d5 4
d12 1
a12 3
#include <json/json.h>

#include <assert.h>
d24 1
d30 2
a31 1
private:
d33 1
a36 1
public:
d38 1
a38 1
  double border;
d42 3
a44 3
  overlay_hex_t** ohl;
  grid_t *grid;
  double scalef;
d48 3
d56 24
a79 25
  {OUTPUT_BLANK,       	0},
  {OUTPUT_WATER,       	0},
  {OUTPUT_PLAINS,		"svg/plains.svg"},
  {OUTPUT_WHIRLPOOL,   	"svg/whirlpool.svg"},
  {OUTPUT_BRIDGE,      	"svg/bridge.svg"},
  {OUTPUT_RAFT,       	"svg/raft.svg"},
  {OUTPUT_PLAIN,		"svg/plains.svg"},
  {OUTPUT_FERTILE,		"svg/fertile.svg"},
  {OUTPUT_SWAMP,       	"svg/swamp.svg"},
  {OUTPUT_SCRUB,       	"svg/scrub.svg"},
  {OUTPUT_PEAK,		"svg/peak.svg"},
  {OUTPUT_VOLCANO,     	"svg/volcano.svg"},
  {OUTPUT_BUILDING,   	"svg/building.svg"},
  {OUTPUT_HOME_DEN,		"svg/den-home.svg"},
  {OUTPUT_EMPTY_DEN,		"svg/den.svg"},
  {OUTPUT_RED_DEN,		"svg/den-red.svg"},
  {OUTPUT_GREEN_DEN,		"svg/den-green.svg"},
  {OUTPUT_GREY_DEN,		"svg/den-grey.svg"},
  {OUTPUT_BLACK_DEN,		"svg/den-black.svg"},
  {OUTPUT_YELLOW_DEN,		"svg/den-yellow.svg"},
  {OUTPUT_TEMPLE,		"svg/temple.svg"},
  {OUTPUT_CURSED,   		"svg/cursed.svg"},
  {OUTPUT_RUIN,		"svg/ruin.svg"},
  {OUTPUT_BAND,       	"svg/band.svg"},
  {OUTPUT_LIZARD,		"svg/lizard.svg"},
d82 1
d106 1
a106 1
fplace_t output_private_t::place(point_t p, double s, double b)
d109 2
a110 2
  double cx = 1.50 * p.x;
  double cy = sqrt(3) * ((double)p.y - yshift);
d113 12
a124 7
  place.center = fpoint_t(cx *s, cy * s);
  place.bounds.left = place.center.x - s - b;
  place.bounds.right = place.center.x + s + b;

  place.bounds.top = place.center.y - sqrt(3)/2 * s - b;
  place.bounds.bottom = place.center.y + sqrt(3)/2 * s + b;

a127 1

d130 1
a130 1
-- Paint
d137 1
a137 1
  for (int j = 0; ohl[j]; j++)
a138 1
      overlay_hex_t *hex = ohl[j];
d143 1
a143 1
      cr->move_to(ohl[j]->hull[0].x, ohl[j]->hull[0].y);
d145 1
a145 1
	cr->line_to(ohl[j]->hull[i].x, ohl[j]->hull[i].y);
d150 7
a156 1
void output_private_t::path_paint(Cairo::RefPtr<Cairo::Context> cr)
d158 8
a165 11
  for (int j = 0; ohl[j]; j++)
    {
      overlay_hex_t * ovh = ohl[j];
      hex_t *hex = ovh->hex;
      if (hex == 0)
	continue;

      int output;
      char *trailer = 0;
      char *header = 0;

d170 7
a176 5
      view_t v = hex->view(player);
      output = v.symbol;
      header = v.owner;
      trailer = v.id;
      
d178 1
a178 1
   Apply center transform
d181 5
a185 5
      cr->begin_new_path();
      cr->move_to(ovh->hull[0].x, ovh->hull[0].y);
      for (int i = 1; i < 6; i++)
	cr->line_to(ovh->hull[i].x, ovh->hull[i].y);
      cr->close_path();
d187 19
a205 22
      switch(output)
	{
	case OUTPUT_WATER:
	case OUTPUT_WHIRLPOOL:
	case OUTPUT_BRIDGE:
	  cr->set_source_rgb(0.80, 0.94, 0.99);
	  break;
	case OUTPUT_BLANK:
	  cr->set_source_rgb(0.8, 0.8, 0.8);
	  break;
	default:
	  cr->set_source_rgb(0.80, 0.99, 0.80);
	  break;
	}
      cr->fill_preserve();
      cr->set_source_rgb(0.0, 0.0, 0.0);
      cr->set_line_width(0.2);
      cr->stroke();

      /* --------------------
	 Place icon (base size is 200x200) scaled by 0.20 to 40x40 so image is places at cx-20, cy-15 to cx+20, cy+25
	 -------------------- */
d207 30
a236 2
      double cx = ovh->center.x;
      double cy = ovh->center.y;
d238 1
a238 17
      if (svgmap[output].handle)
	{
	  cr->save();
	  cairo_t *c = (cairo_t*)(cr->cobj());
	  cr->translate(cx - 20.0, cy - 15.0);
	  cr->scale(0.20, 0.20);
	  rsvg_handle_render_cairo(svgmap[output].handle, c);
	  cr->restore();
	}

      Cairo::TextExtents e;
      if (trailer)
	{
	  cr->get_text_extents(trailer, e);
	  cr->move_to(cx -e.width/2, cy + sqrt(3)/2*scalef - 2);
	  cr->show_text(trailer);
	}
d240 29
d270 3
a272 7
      cr->set_source_rgb(1.0, 0.0, 0.0);
      if (header)
	{
	  cr->get_text_extents(header, e);
	  cr->move_to(cx - e.width/2, cy - sqrt(3)/2*scalef + e.height + 2);
	  cr->show_text(header);
	}
d274 9
d284 5
a288 13
      if (v.band)
	{
	  char band[10];
	  snprintf(band, 10, "%d", v.band);
	  cr->get_text_extents(band, e);
	  cr->move_to(cx - e.width, cy - 5);
	  cr->show_text(band);
	  cr->save();
	  cr->translate(cx, cy - 25);
	  cr->scale(0.15, 0.15);
	  rsvg_handle_render_cairo(svgmap[OUTPUT_LIZARD].handle, (cairo_t*)(cr->cobj()));
	  cr->restore();
	}
d290 7
d298 1
a298 4
  for (int j = 0; ohl[j]; j++)
    {
      overlay_hex_t * ovh = ohl[j];
      if (ovh->hex->active)
d300 1
a300 5
	  cr->begin_new_path();
	  cr->move_to(ohl[j]->hull[0].x, ohl[j]->hull[0].y);
	  for (int i = 1; i < 6; i++)
	    cr->line_to(ohl[j]->hull[i].x, ohl[j]->hull[i].y);
	  cr->close_path();
d305 6
d340 1
a340 1
  misc_t::log("stroke extents left = %f top = %f", fb.left, fb.top);
d344 2
a345 1
  cr->translate(-fb.left + border, -fb.top + border);
d361 1
a361 1
  ohl = ov->extract(p);
d367 5
a371 1
  assert(ohl[0] != 0);
d376 1
a376 1
      int hex_min_weight;
d378 1
a378 1
      for (int i = 0; ohl[i]; i++)
d380 2
a381 2
	  int x = ohl[i]->xy.x;
	  int y = ohl[i]->xy.y;
d384 1
a384 1
	  for (int j = 0; ohl[j]; j++)
d386 2
a387 2
	      int xd = abs(ohl[j]->xy.x - x);
	      int yd = abs(ohl[j]->xy.y - y);
d394 1
a394 1
	      hex_min_weight = i;
d397 1
a397 1
      point_t center = ohl[hex_min_weight]->xy;
a401 1

d404 1
a404 1
      misc_t::log("Hex %s (%d,%d) has minimum weight %d\n", ohl[hex_min_weight]->hex->getid(), ohl[hex_min_weight]->xy.x, ohl[hex_min_weight]->xy.y, min_weight);
d406 1
a406 1
      for (int i = 0; ohl[i]; i++)
d408 1
a408 1
	  point_t pt = ohl[i]->xy + diff;
d414 1
a414 1
	  ohl[i]->xy = pt;
d435 1
a435 3
  fbox_t edge;

  for (int i = 0; ohl[i]; i++)
d437 4
a440 13
      point_t o = ohl[i]->xy;
      fplace_t b = place(o, scalef, 0);
      ohl[i]->center = b.center;

      double cx = b.center.x;
      double cy = b.center.y;

      for (int j = 0; j < 6; j++)
	{
	  double x = cos(j * 60 * M_PI / 180);
	  double y = sin(j * 60 * M_PI / 180);
	  ohl[i]->hull[j] = fpoint_t(cx + x * scalef, cy + y * scalef);
	}
d442 1
a442 4
      if (i == 0)
	edge = b.bounds;
      else
       	edge.setunion(b.bounds);
d445 2
a446 3
  
  width = (edge.right - edge.left) + (2 * border);
  height = (edge.bottom - edge.top) + (2 * border);
d449 1
d452 1
a452 1
-- SVG
d456 1
a456 1
void* output_t::svg(char *file, int p)
d458 31
a488 5
  priv = new output_private_t(grid, p);
  Cairo::RefPtr<Cairo::SvgSurface> surface = Cairo::SvgSurface::create(file, priv->width, priv->height);
  Cairo::RefPtr<Cairo::Context> cr = Cairo::Context::create(surface);
  priv->paint(cr);
  return 0;
d491 1
d494 1
a494 1
-- single
d498 7
a504 1
#ifdef HaveSingle
d506 6
a511 5
void output_t::single(grid_t* grid)
{
  overlay_grid_t *ov = new overlay_grid_t(grid);
  ov->mark(0);
  overlay_hex_t **ol = ov->extract(0);
d513 2
a514 1
  double border = 5.0;
d516 3
a518 1
  fbox_t edge;
d520 1
a520 13
  for (int i = 0; overlay_hex_t *oh = ol[i]; i++)
    {
      fplace_t b = place(oh->xy, scalef, border);
      if (i > 0)
	{
	  if (b.bounds.left < edge.left) edge.left = b.bounds.left;
	  if (b.bounds.right > edge.right) edge.right = b.bounds.right;
	  if (b.bounds.top < edge.top) edge.top = b.bounds.top;
	  if (b.bounds.bottom > edge.bottom) edge.bottom = b.bounds.bottom;
	}
      else
	edge = b.bounds;
    }
d522 6
a527 1
  printf("<div style=\"position:relative;width:%fpt;height:%fpt;\">\n", edge.right - edge.left, edge.bottom - edge.top);
d529 1
a529 1
  for (int i = 0; overlay_hex_t *oh = ol[i]; i++)
d531 15
a545 4
      fplace_t b = place(oh->xy, scalef, border);
      overlay_hex_t* tl[2];
      tl[0] = oh;
      tl[1] = 0;
d547 2
a548 2
      int width = (int)(b.bounds.right - b.bounds.left);
      int height = (int)(b.bounds.bottom - b.bounds.top);
d550 2
a551 2
      char file[1024];
      snprintf(file, 1024, "single-%s.svg", oh->hex->id());
d553 1
a553 3
      Cairo::RefPtr<Cairo::SvgSurface> surface = Cairo::SvgSurface::create(file, width, height);
      Cairo::RefPtr<Cairo::Context> cr = Cairo::Context::create(surface);
      paint(grid, cr, border, 0, tl);
d555 1
a555 1
      printf("<span style=\"position:absolute;left:%fpt;top:%fpt;\"><img src=\"single-%s.svg\"/></span>\n", b.bounds.left - edge.left, b.bounds.top - edge.top, oh->hex->id());
d557 4
a560 1
      surface->flush();
d562 9
a571 1
#endif
d575 1
a575 1
-- output_t(grid_t*)
d579 1
a579 1
output_t::output_t(grid_t *g) 
d581 2
a582 3
  g_type_init();
  grid = g;
}
d584 9
a592 6
output_private_t::output_private_t(grid_t *g, int p)
{
  scalef = 40.0;
  border = 5;
  grid = g;
  overlay(p);
d594 2
a595 4
  for (int i = 0; i < OUTPUT_LAST; i++)
    {
      if (svgmap[i].svgfile)
	svgmap[i].handle = rsvg_handle_new_from_file(svgmap[i].svgfile, 0);
d597 17
a613 1
	svgmap[i].handle = 0;
d615 4
d629 1
a629 89
  overlay_grid_t *ov = new overlay_grid_t(grid);
  ov->mark(p);
  overlay_hex_t **ol = ov->extract(p);

  fbox_t edge;
  edge.left = 2 * grid->width * scalef;
  edge.right = -2 * grid->width * scalef;
  edge.top = 2 * grid->height * scalef;
  edge.bottom = -2 * grid->height * scalef;

  for (int i = 0; ol[i]; i++)
    {
      point_t o = ol[i]->xy;
      fplace_t b = place(o, scalef, 0);
      
      if (b.bounds.left < edge.left)
	edge.left = b.bounds.left;
      if (b.bounds.right > edge.right)
	edge.right = b.bounds.right;
      
      if (b.bounds.top < edge.top)
	edge.top = b.bounds.top;
      if (b.bounds.bottom > edge.bottom)
	edge.bottom = b.bounds.bottom;
    }
  
  //  edge.left -= r;
  //  edge.right += r;
  //  edge.bottom -= sqrt(3)/2.0*r;
  //  edge.top += sqrt(3)/2.0*r;
  
  double border = 5.0;
  
  int width = (int)((edge.right - edge.left) + 2 * border);
  int height = (int)((edge.bottom - edge.top) + 2 * border);

  json_object* img = json_object_new_object();

  Cairo::RefPtr<Cairo::SvgSurface> surface = Cairo::SvgSurface::create("/dev/null", width, height);
  Cairo::RefPtr<Cairo::Context> cr = Cairo::Context::create(surface);
  fbox_t box = paint(grid, cr, border, p, ol);

  fprintf(stderr, "%f %f %f %f\n", box.left, box.right, box.bottom, box.top);

  json_object_object_add(img, "border", json_object_new_double(border));
  json_object_object_add(img, "width", json_object_new_int(width));
  json_object_object_add(img, "height", json_object_new_int(height));

  json_object* array = json_object_new_array();

  for (int i = 0; ol[i]; i++)
    {
      json_object* h = json_object_new_object();
      fplace_t pl = place(ol[i]->xy, scalef, 0);
      json_object *path = json_object_new_array();
      hex_t *hex = ol[i]->hex;
      json_object_object_add(h, "title", json_object_new_string(hex->getid()));

      json_object *center = json_object_new_object();
      json_object_object_add(center, "x", json_object_new_double(pl.center.x));
      json_object_object_add(center, "y", json_object_new_double(pl.center.y));

      json_object_object_add(h, "center", center);

      for (int j = 0; j < 6; j++)
	{
	  double x = cos(j * 60 * M_PI / 180);
	  double y = sin(j * 60 * M_PI / 180);
	  json_object* xy = json_object_new_object();
	  json_object_object_add(xy, "x", json_object_new_double(pl.center.x + x * scalef -box.left + border));
	  json_object_object_add(xy, "y", json_object_new_double(pl.center.y + y * scalef -box.bottom + border));
	  json_object_array_add(path, xy);
	}
      json_object_object_add(h, "path", path);
      json_object_array_add(array, h);
    }

  json_object_object_add(img, "hexes", array);
  //  json_object_to_file_ext(file, array, JSON_C_TO_STRING_PRETTY);
  if (file)
    {
      json_object_to_file_ext(file, img, JSON_C_TO_STRING_PLAIN);
      return 0;
    }
  else
    {
      const char* ret = json_object_to_json_string_ext(img, JSON_C_TO_STRING_PLAIN);
      return (void*)ret;
    }
d639 4
a642 3
  overlay(0);
  Cairo::RefPtr<Cairo::SvgSurface> surface = Cairo::SvgSurface::create("/dev/null", width, height);
  Cairo::RefPtr<Cairo::Context> cr = Cairo::Context::create(surface);
d644 2
d651 4
a654 1
  misc_t::log("nx,ny = %f,%f : width,height = %d,%d", nx, ny, width, height);
d658 1
a658 1
  path_extents(grid, cr, ol);
d663 2
a664 2
  nx += fb.left - border;
  ny += fb.top - border;
d668 1
a668 1
  for (int j = 0; ol[j]; j++)
d670 1
a670 2
      overlay_hex_t *hex = ol[j];
      if (hex == 0)
d672 1
a672 1
      ol[j]->hex->active = 0;
d675 1
a675 1
      cr->move_to(ol[j]->hull[0].x, ol[j]->hull[0].y);
d677 1
a677 1
	cr->line_to(ol[j]->hull[i].x, ol[j]->hull[i].y);
d681 3
a683 3
	  hit = ol[j]->hex;
	  ol[j]->hex->active = 1;
	  misc_t::log("Hit for hex %s", hit->getid());
d689 38
@


1.2
log
@Save before changing svg stuff.
@
text
@d7 2
a8 1
#include <librsvg/rsvg-cairo.h>
a11 1
#include "point.h"
d14 100
a113 35
svgmap_t output_t::svgmap[OUTPUT_LAST] = {
    {OUTPUT_BLANK,       	0},
    {OUTPUT_WATER,       	0},
    {OUTPUT_PLAINS,		0},
    {OUTPUT_WHIRLPOOL,   	"svg/whirlpool.svg"},
    {OUTPUT_BRIDGE,      	"svg/bridge.svg"},
    {OUTPUT_RAFT,       	"svg/raft.svg"},
    {OUTPUT_PLAIN,		"svg/plains.svg"},
    {OUTPUT_FERTILE,		"svg/fertile.svg"},
    {OUTPUT_SWAMP,       	"svg/swamp.svg"},
    {OUTPUT_SCRUB,       	"svg/scrub.svg"},
    {OUTPUT_PEAK,		"svg/peak.svg"},
    {OUTPUT_VOLCANO,     	"svg/volcano.svg"},
    {OUTPUT_BUILDING,   	"svg/building.svg"},
    {OUTPUT_HOME_DEN,		"svg/den-home.svg"},
    {OUTPUT_EMPTY_DEN,		"svg/den.svg"},
    {OUTPUT_RED_DEN,		"svg/den-red.svg"},
    {OUTPUT_GREEN_DEN,		"svg/den-green.svg"},
    {OUTPUT_GREY_DEN,		"svg/den-grey.svg"},
    {OUTPUT_BLACK_DEN,		"svg/den-black.svg"},
    {OUTPUT_YELLOW_DEN,		"svg/den-yellow.svg"},
    {OUTPUT_TEMPLE,		"svg/temple.svg"},
    {OUTPUT_CURSED,   		"svg/cursed.svg"},
    {OUTPUT_RUIN,		"svg/ruin.svg"},
    {OUTPUT_BAND,       	"svg/band.svg"},
    {OUTPUT_LIZARD,		"svg/lizard.svg"},
  };


fpoint_t output_t::scale(point_t p, double r)
{
  double yshift = (double)(abs(p.x)%2) / 2.0;
  double cx = 1.50 * r * p.x;
  double cy = sqrt(3) * r * ((double)p.y - yshift);
  return fpoint_t(cx, cy);
d116 1
d123 1
a123 1
void output_t::path_extents(grid_t* grid, Cairo::RefPtr<Cairo::Context> cr, overlay_hex_t **hl)
a124 2
  double r = 40.0;

d126 1
a126 1
  for (int j = 0; hl[j]; j++)
d128 1
a128 1
      overlay_hex_t *hex = hl[j];
a131 4
      fpoint_t p = scale(hex->xy, r);
      double cx = p.x;
      double cy = p.y;

d133 3
a135 10

      for (int i = 0; i < 6; i++)
	{
	  double x = cos(i * 60 * M_PI / 180);
	  double y = sin(i * 60 * M_PI / 180);
	  if (i)
	    cr->line_to(cx + x * r, cy + y * r);
	  else
	    cr->move_to(cx + x * r, cy + y * r);
	}
d140 1
a140 2

void output_t::path_paint(grid_t* grid, Cairo::RefPtr<Cairo::Context> cr, int player, overlay_hex_t **hl)
d142 1
a142 3
  double r = 40.0;

  for (int j = 0; hl[j]; j++)
d144 1
a144 1
      overlay_hex_t * ovh = hl[j];
a148 1
      //      point_t p = ovh->xy;
a165 4
      fpoint_t p = scale(ovh->xy, r);
      double cx = p.x;
      double cy = p.y;

d167 3
a169 9
      for (int i = 0; i < 6; i++)
	{
	  double x = cos(i * 60 * M_PI / 180);
	  double y = sin(i * 60 * M_PI / 180);
	  if (i)
	    cr->line_to(cx + x * r, cy + y * r);
	  else
	    cr->move_to(cx + x * r, cy + y * r);
	}
d171 1
d179 3
d186 1
a186 2
      if (output)
	cr->fill_preserve();
d188 1
a188 1
      cr->set_line_width(0.1);
d195 3
d212 1
a212 1
	  cr->move_to(cx -e.width/2, cy + sqrt(3)/2*r - 2);
d221 1
a221 1
	  cr->move_to(cx - e.width/2, cy - sqrt(3)/2*r + e.height + 2);
d234 2
a235 2
	  cr->translate(cx, cy - 20);
	  cr->scale(0.10, 0.10);
d240 16
d258 7
a264 1
fbox_t output_t::paint(grid_t* grid, Cairo::RefPtr<Cairo::Context> cr, double border, int p, overlay_hex_t **hl)
a265 1

d269 1
a269 1
  cr->set_font_size(12);
d279 1
a279 1
  path_extents(grid, cr, hl);
d281 1
a281 1
  cr->get_stroke_extents(fb.left, fb.bottom, fb.right, fb.top);
d284 1
a284 1
  printf("top = %f bottom = %f\n", fb.top, fb.bottom);
d287 3
a289 2
  cr->translate(-fb.left + border, -fb.bottom + border);
  path_paint(grid, cr, p, hl);
a290 1
  cr->show_page();
d296 1
a296 1
-- SVG
d300 1
a300 3
#define min(a, b) (a < b ? a : b)

void output_t::svg(grid_t* grid, char *file, double r, int p)
d302 7
a308 16
  if (p == 0)
    {
      fbox_t f = grid->fbox(r);
      Cairo::RefPtr<Cairo::SvgSurface> surface = Cairo::SvgSurface::create(file, (f.right - f.left + 20.0), (f.top - f.bottom + 20.0));
      Cairo::RefPtr<Cairo::Context> cr = Cairo::Context::create(surface);

      overlay_grid_t *ov = new overlay_grid_t(grid);
      ov->mark(p);
      overlay_hex_t **ol = ov->extract(p);


      hex_t ** hl = new hex_t*[grid->width * grid->height + 1];
      for (int j = 0; j < grid->size; j++)
	hl[j] = (*grid)[j];
      
      hl[grid->width * grid->height] = 0;
d310 2
a311 5
      cr->save(); // save the state of the context
      cr->set_source_rgb(0.86, 0.85, 0.47);
      cr->restore();  // color is back to black now
      paint(grid, cr, r, p, hl);
    }
a313 8
      overlay_grid_t *ov = new overlay_grid_t(grid);
      ov->mark(p);
      overlay_hex_t **ol = ov->extract(p);

      for (int i = 0; ol[i]; i++)
	printf("%s ", ol[i]->hex->id());
      printf("\n");

d317 1
a317 1
      for (int i = 0; ol[i]; i++)
d319 2
a320 2
	  int x = ol[i]->xy.x;
	  int y = ol[i]->xy.y;
d323 1
a323 1
	  for (int j = 0; ol[j]; j++)
d325 2
a326 2
	      int xd = abs(ol[j]->xy.x - x);
	      int yd = abs(ol[j]->xy.y - y);
d336 1
a336 1
      point_t center = ol[hex_min_weight]->xy;
d344 3
a346 2
      printf("Hex %s (%d,%d) has minimum weight %d\n", ol[hex_min_weight]->hex->id(), ol[hex_min_weight]->xy.x, ol[hex_min_weight]->xy.y, min_weight);
      for (int i = 0; ol[i]; i++)
d348 1
a348 1
	  point_t pt = ol[i]->xy + diff;
d352 5
a356 10
	  if (pt.y < 0) pt.y += grid->width;
	  if (pt.y >= grid->width) pt.y -= grid->width;
	  ol[i]->xy = pt;
	  //	  printf("%s -> %d,%d\n", ol[i]->hex->id(), pt.x, pt.y);
	}
      fbox_t edge;
      edge.left = 2 * grid->width * r;
      edge.right = -2 * grid->width * r;
      edge.top = -2 * grid->height * r;
      edge.bottom = 2 * grid->height * r;
d375 12
a386 1
      for (int i = 0; ol[i]; i++)
d388 15
a402 1
	  point_t o = ol[i]->xy;
d404 5
a408 1
	  // If x is odd (x%2 == 1) then y is offset by 1/2.
d410 36
a445 11
	  fpoint_t m = scale(o, r);
	  
	  if (m.x < edge.left)
	    edge.left = m.x;
	  if (m.x > edge.right)
	    edge.right = m.x;
	  
	  if (m.y < edge.bottom)
	    edge.bottom = m.y;
	  if (m.y > edge.top)
	    edge.top = m.y;
d447 3
d451 1
a451 4
      edge.left -= r;
      edge.right += r;
      edge.bottom -= sqrt(3)/2.0*r;
      edge.top += sqrt(3)/2.0*r;
d453 6
a458 1
      double border = 5.0;
d460 5
a464 2
      int width = (int)((edge.right - edge.left) + 2 * border);
      int height = (int)((edge.top - edge.bottom) + 2 * border);
d468 3
d472 1
a472 1
      paint(grid, cr, border, p, ol);
d475 1
d477 7
a483 1
output_t::output_t() 
d485 11
a495 1
  rsvg_init();
d503 152
@


1.1
log
@Initial revision
@
text
@d43 8
d57 1
a57 1
void output_t::path_extents(grid_t* grid, Cairo::RefPtr<Cairo::Context> cr, double r, hex_t **hl)
d59 2
d64 1
a64 1
      hex_t *hex = hl[j];
d67 6
a72 4
      point_t p = hex->xy;
      double yshift = abs(p.x)%2 / 2.0;
      double cx = 1.50 * r * p.x;
      double cy = sqrt(3) * r * (p.y - yshift);
a83 1
      cr->move_to(cx, cy);
d87 2
a88 1
void output_t::path_paint(grid_t* grid, Cairo::RefPtr<Cairo::Context> cr, double r, hex_t **hl)
d90 2
d94 2
a95 1
      hex_t *hex = hl[j];
d99 1
a99 3
      printf("%s ", hex->id());

      point_t p = hex->xy;
d104 5
a108 1
      view_t v = hex->view(0);
d113 7
a119 7
      // printf("%d (%d x %d)\n", j, p.x, p.y);

      double yshift = abs(p.x)%2 / 2.0;
      double cx = 1.50 * r * p.x;
      double cy = sqrt(3) * r * (p.y - yshift);

      //      printf("%d : %d %d\n", j, tt[j].x, tt[j].y);
d146 1
a146 1
      cr->set_line_width(0.4);
d149 4
d157 2
a158 3
	  cr->translate(cx, cy + 0.6*r);
	  cr->scale(r / 150, r/150);
	  cr->translate(-100, -200);
d186 1
a186 1
	  cr->move_to(cx - e.width, cy - r/8);
d189 2
a190 3
	  cr->translate(cx, cy);
	  cr->scale(r/350, r/350);
	  cr->translate(0,-200);
a194 1
  printf("\n");
d197 1
a197 1
fbox_t output_t::paint(grid_t* grid, Cairo::RefPtr<Cairo::Context> cr, double r, hex_t **hl)
d213 2
a214 1
  path_extents(grid, cr, r, hl);
d217 3
d221 2
a222 2
  cr->translate(-fb.left + 10, -fb.bottom + 10);
  path_paint(grid, cr, r, hl);
d244 5
d258 1
a258 1
      paint(grid, cr, r, hl);
d262 7
a268 19
      int c = 0;
      for (int i = 0; i < grid->width; i++)
	for (int j = 0; j < grid->height; j++)
	  {
	    hex_t *hex = (*grid)(i, j);
	    if (hex->check(p))
	      c++;
	  }

      hex_t ** hl = new hex_t*[c + 1];
      c = 0;
      for (int i = 0; i < grid->width; i++)
	for (int j = 0; j < grid->height; j++)
	  {
	    hex_t *hex = (*grid)(i, j);
	    if (hex->check(p))
	      hl[c++] = hex;
	  }
      hl[c] = 0;
d273 1
a273 1
      for (int i = 0; hl[i]; i++)
d275 3
a277 3
	  int x = hl[i]->xy.x;
	  int y = hl[i]->xy.y;

d279 1
a279 1
	  for (int j = 0; j < c; j++)
d281 2
a282 2
	      int xd = abs(hl[j]->xy.x - x);
	      int yd = abs(hl[j]->xy.y - y);
d292 1
a292 2
      printf("Hex %s has minimum weight %d\n", hl[hex_min_weight]->id(), min_weight);
      point_t center = hl[hex_min_weight]->xy;
d295 4
a298 10
      int left = 2 * grid->width;
      int right = -2 * grid->width;
      int bottom = 2 * grid->height;
      int top = -2 * grid->height;

      fbox_t fb;
      fb.left = 2 * grid->width;
      fb.right = -2 * grid->width;
      fb.top = 2 * grid->height;
      fb.bottom = -2 * grid->height;
d300 2
a301 1
      for (int i = 0; hl[i]; i++)
d303 8
a310 14
	  int x = hl[i]->xy.x - center.x;
	  int y = hl[i]->xy.y - center.y;
   
	  double mx = 1.5 * x;
	  double my = sqrt(3) * (y - abs(x%2)/2.0);

	  if ((mx - 1.0) < fb.left)
	    fb.left = mx - 1.0;
	  if ((mx + 1.0) > fb.right)
	    fb.right = mx + 1.0;
	  if ((my - sqrt(3)/2.0) < fb.top)
	    fb.top = my - sqrt(3)/2.0;
	  if ((my + sqrt(3)/2.0) > fb.bottom)
	    fb.bottom = my + sqrt(3)/2.0;
d312 5
d318 1
a318 2
      fbox_t border;
      fbox_t edge = fb;
d320 10
a329 1
      border.left = border.right = border.top = border.bottom = 10.0;
d331 1
a331 2
      int width = (int)((edge.right - edge.left) *  r + border.left + border.right);
      int height = (int)((edge.bottom - edge.top) *  r + border.top + border.bottom);
d333 3
a335 1
      for (int i = 0; i < c; i++)
d337 3
a339 2
	  int x = hl[i]->xy.x - center.x;
	  int y = hl[i]->xy.y - center.y;
d341 11
a351 4
	  if (left > x) left = x;
	  if (right < x) right = x;
	  if (bottom > y) bottom = y;
	  if (top < y) top = y;
d354 10
a363 4
      printf("Bounding box is (%d, %d) x (%d, %d)\n", left, bottom, right, top);
      int w = right - left + 1;
      int h = top - bottom + 1;
      printf("Size is %d x %d\n", w, h);
d366 2
a367 1
      paint(grid, cr, r, hl);
@
